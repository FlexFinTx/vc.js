{"version":3,"sources":["../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/constants.ts","../../src/Ed25519Signature2018.ts","../../src/strictExpansionMap.ts","../../src/ProofSet.ts","../../src/getTypeInfo.ts","../../src/sign.ts","../../src/VerificationError.ts","../../src/verify.ts","../../src/vc-ld/purposes/ProofPurpose.ts","../../src/vc-ld/constants.ts","../../src/vc-ld/purposes/ControllerProofPurpose.ts","../../src/vc-ld/purposes/AssertionProofPurpose.ts","../../src/vc-ld/purposes/CredentialIssuancePurpose.ts","../../src/vc-ld/purposes/AuthenticationProofPurpose.ts","../../src/vc-ld/checkCredential.ts","test-jwt.js","../../src/vc-ld/checkPresentation.ts","../../src/vc-ld/verify.ts","../../src/vc-ld/prove.ts","../../src/vc-ld/issue.ts","../../src/vc-jwt/issue.ts","../../src/vc-jwt/prove.ts","../../src/vc-jwt/verify.ts","documentLoader.js","test-ld.js","App.js","serviceWorker.js","index.js"],"names":["Symbol","iterator","asyncIterator","_catch","body","recover","result","e","then","securityConstants","require","constants","SECURITY_CONTEXT_URL","SECURITY_CONTEXT_V1_URL","SECURITY_CONTEXT_V2_URL","SECURITY_PROOF_URL","SECURITY_SIGNATURE_URL","sha256","data","h","crypto","Ed25519Signature2018","this","options","useNativeCanonize","type","key","sign","payload","Buffer","EdDSA","keyUtils","alg","b64","crit","verify","signature","verified","console","documentLoader","expansionMap","skipExpansion","algorithm","format","useNative","proof","document","c14nProofOptions","c14nDocument","verifyData","Error","detachedJws","purpose","compactProof","date","Date","suite","compactToRelative","verificationMethod","creator","id","framed","verifier","jws","Ed25519KeyPair","purposeResult","error","_Pact","prototype","onFulfilled","onRejected","state","s","callback","_settle","v","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_iteratorSymbol","_forOf","target","check","step","reject","_cycle","next","done","return","_fixup","TypeError","values","i","length","push","array","_forTo","info","ProofSet","_getProofs","legacy","proofSet","jsonld","proofProperty","_verify","suites","Promise","matches","r","_addToJSON","Object","serializeError","configurable","writable","Array","doc","results","errors","input","expandedProof","ctx","compacted","alias","toExpand","expanded","types","getTypeInfo","url","err","VerificationError","concat","urlError","ProofPurpose","term","maxTimestampDelta","Infinity","isNaN","expected","delta","created","valid","CREDENTIALS_CONTEXT_V1_URL","ControllerProofPurpose","controller","verificationMethods","vm","_options","verificationId","owner","controllerId","AssertionProofPurpose","CredentialIssuancePurpose","issuer","AuthenticationProofPurpose","challenge","domain","update","dateRegex","RegExp","_getId","obj","jwk","checkCredential","credential","evidenceId","checkPresentation","presentation","context","verifyCredential","checkStatus","jSigsVerify","credentialStatus","_verifyCredential","createPresentation","verifiableCredential","holder","credentials","credentialResults","presentationResult","unsignedPresentation","cr","_verifyPresentation","credentialTemplate","isObject","subject","iss","sub","vc","moment","signer","vp","createVerifiablePresentation","unlockedDID","localOverrides","withoutFragment","split","contextUrl","documentUrl","didDoc","_credential","testLd","a","log","from","publicKey","credentialSubject","vcjs","verifiablePresentation","presentationVerified","privateKeyJwk","header","kid","complete","verifyFactory","publicKeyJwk","vpOptions","testJwt","credentialIssued","credentialVerified","presentationCreated","presentationProved","App","className","onClick","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.c003dccb.chunk.js","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","const { constants: securityConstants } = require('security-context');\n\nexport default {\n  SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,\n  SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_PROOF_URL: 'https://w3id.org/security#proof',\n  SECURITY_SIGNATURE_URL: 'https://w3id.org/security#signature',\n};\n","import jsonld from 'jsonld';\nimport constants from './constants';\nimport crypto from 'crypto';\n\nimport { Ed25519KeyPair, EdDSA, keyUtils } from '@transmute/did-key-ed25519';\n\nconst sha256 = (data: any) => {\n  const h = crypto.createHash('sha256');\n  h.update(data);\n  return h.digest();\n};\n\nexport interface IEd25519Signature2018Options {\n  key?: any;\n  date?: any;\n  signer?: any;\n}\n\nexport class Ed25519Signature2018 {\n  public useNativeCanonize: boolean = false;\n  public key: any;\n  public proof: any;\n  public date: any;\n  public creator: any;\n  public type: string = 'Ed25519Signature2018';\n  public signer: any;\n  public verifier: any;\n  public verificationMethod?: string;\n  constructor(options: IEd25519Signature2018Options = {}) {\n    this.signer = options.signer;\n    this.date = options.date;\n    if (options.key) {\n      this.key = options.key;\n      this.verificationMethod = this.key.id;\n      this.signer = {\n        sign: async ({ data }: any) => {\n          const header = {\n            alg: 'EdDSA',\n            b64: false,\n            crit: ['b64'],\n          };\n          const payload = Buffer.from(data);\n          const _jws = await EdDSA.signDetached(\n            payload,\n            keyUtils.privateKeyJwkFromPrivateKeyBase58(\n              this.key.privateKeyBase58\n            ),\n            header\n          );\n          return _jws;\n        },\n      };\n\n      this.verifier = {\n        verify: async ({ data, signature }: any) => {\n          let verified = false;\n          try {\n            verified = await EdDSA.verifyDetached(\n              signature,\n              data,\n              keyUtils.publicKeyJwkFromPublicKeyBase58(this.key.publicKeyBase58)\n            );\n          } catch (e) {\n            console.error('An error occurred when verifying signature: ', e);\n          }\n          return verified;\n        },\n      };\n    }\n  }\n\n  async canonize(\n    input: any,\n    { documentLoader, expansionMap, skipExpansion }: any\n  ) {\n    return jsonld.canonize(input, {\n      algorithm: 'URDNA2015',\n      format: 'application/n-quads',\n      documentLoader,\n      expansionMap,\n      skipExpansion,\n      useNative: this.useNativeCanonize,\n    });\n  }\n\n  async canonizeProof(proof: any, { documentLoader, expansionMap }: any) {\n    // `jws`,`signatureValue`,`proofValue` must not be included in the proof\n    // options\n    proof = { ...proof };\n    delete proof.jws;\n    delete proof.signatureValue;\n    delete proof.proofValue;\n    return this.canonize(proof, {\n      documentLoader,\n      expansionMap,\n      skipExpansion: false,\n    });\n  }\n\n  async createVerifyData({\n    document,\n    proof,\n    documentLoader,\n    expansionMap,\n  }: any) {\n    // concatenate hash of c14n proof options and hash of c14n document\n    const c14nProofOptions = await this.canonizeProof(proof, {\n      documentLoader,\n      expansionMap,\n    });\n    const c14nDocument = await this.canonize(document, {\n      documentLoader,\n      expansionMap,\n    });\n    return Buffer.concat([sha256(c14nProofOptions), sha256(c14nDocument)]);\n  }\n\n  async matchProof({\n    proof,\n  }: // document,\n  // purpose,\n  // documentLoader,\n  // expansionMap,\n  any) {\n    return proof.type === this.type;\n  }\n\n  async updateProof({ proof }: any) {\n    // extending classes may do more\n    return proof;\n  }\n\n  async sign({ verifyData, proof }: any) {\n    if (!(this.signer && typeof this.signer.sign === 'function')) {\n      throw new Error('A signer API has not been specified.');\n    }\n\n    const detachedJws = await this.signer.sign({ data: verifyData });\n    proof.jws = detachedJws;\n    return proof;\n  }\n\n  async createProof({\n    document,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof,\n  }: any) {\n    // build proof (currently known as `signature options` in spec)\n    let proof;\n    if (this.proof) {\n      // use proof JSON-LD document passed to API\n      proof = await jsonld.compact(this.proof, constants.SECURITY_CONTEXT_URL, {\n        documentLoader,\n        expansionMap,\n        compactToRelative: false,\n      });\n    } else {\n      // create proof JSON-LD document\n      proof = { '@context': constants.SECURITY_CONTEXT_URL };\n    }\n\n    // ensure proof type is set\n    proof.type = this.type;\n\n    // set default `now` date if not given in `proof` or `options`\n    let date = this.date;\n    if (proof.created === undefined && date === undefined) {\n      date = new Date();\n    }\n\n    // ensure date is in string format\n    if (date !== undefined && typeof date !== 'string') {\n      date = new Date(date).toISOString();\n    }\n\n    // add API overrides\n    if (date !== undefined) {\n      proof.created = date;\n    }\n    // `verificationMethod` is for newer suites, `creator` for legacy\n    if (this.verificationMethod !== undefined) {\n      proof.verificationMethod = this.verificationMethod;\n    }\n    if (this.creator !== undefined) {\n      proof.creator = this.creator;\n    }\n\n    // add any extensions to proof (mostly for legacy support)\n    proof = await this.updateProof({\n      document,\n      proof,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof,\n    });\n\n    // allow purpose to update the proof; the `proof` is in the\n    // SECURITY_CONTEXT_URL `@context` -- therefore the `purpose` must\n    // ensure any added fields are also represented in that same `@context`\n    proof = await purpose.update(proof, {\n      document,\n      suite: this,\n      documentLoader,\n      expansionMap,\n    });\n\n    // create data to sign\n    const verifyData = await this.createVerifyData({\n      document,\n      proof,\n      documentLoader,\n      expansionMap,\n      compactProof,\n    });\n\n    // sign data\n    proof = await this.sign({\n      verifyData,\n      document,\n      proof,\n      documentLoader,\n      expansionMap,\n    });\n\n    return proof;\n  }\n\n  async getVerificationMethod({ proof, documentLoader }: any) {\n    let { verificationMethod } = proof;\n\n    if (!verificationMethod) {\n      // backwards compatibility support for `creator`\n      const { creator } = proof;\n      verificationMethod = creator;\n    }\n\n    if (typeof verificationMethod === 'object') {\n      verificationMethod = verificationMethod.id;\n    }\n\n    if (!verificationMethod) {\n      throw new Error('No \"verificationMethod\" or \"creator\" found in proof.');\n    }\n\n    // Note: `expansionMap` is intentionally not passed; we can safely drop\n    // properties here and must allow for it\n    const framed = await jsonld.frame(\n      verificationMethod,\n      {\n        // '@context': constants.SECURITY_CONTEXT_URL,\n        '@context': constants.SECURITY_CONTEXT_URL,\n        '@embed': '@always',\n        id: verificationMethod,\n      },\n      { documentLoader, compactToRelative: false }\n    );\n\n    if (!framed) {\n      throw new Error(`Verification method ${verificationMethod} not found.`);\n    }\n\n    // ensure verification method has not been revoked\n    if (framed.revoked !== undefined) {\n      throw new Error('The verification method has been revoked.');\n    }\n\n    return framed;\n  }\n\n  async verifySignature({ verifyData, verificationMethod, proof }: any) {\n    let { verifier } = this;\n    if (!verifier) {\n      const key = await Ed25519KeyPair.from(verificationMethod);\n      verifier = key.verifier();\n    }\n    return verifier.verify({ data: verifyData, signature: proof.jws });\n  }\n\n  async verifyProof({\n    proof,\n    document,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof,\n  }: any) {\n    try {\n      // create data to verify\n      const verifyData = await this.createVerifyData({\n        document,\n        proof,\n        documentLoader,\n        expansionMap,\n        compactProof,\n      });\n\n      // fetch verification method\n      const verificationMethod = await this.getVerificationMethod({\n        proof,\n        document,\n        documentLoader,\n        expansionMap,\n      });\n\n      // verify signature on data\n      const verified = await this.verifySignature({\n        verifyData,\n        verificationMethod,\n        document,\n        proof,\n        documentLoader,\n        expansionMap,\n      });\n      if (!verified) {\n        throw new Error('Invalid signature.');\n      }\n\n      // ensure proof was performed for a valid purpose\n      const purposeResult = await purpose.validate(proof, {\n        document,\n        suite: this,\n        verificationMethod,\n        documentLoader,\n        expansionMap,\n      });\n\n      // console.log(purposeResult);\n\n      if (!purposeResult.valid) {\n        throw purposeResult.error;\n      }\n\n      return { verified: true, purposeResult };\n    } catch (error) {\n      return { verified: false, error };\n    }\n  }\n}\n","// strict expansion map disallows dropping properties when expanding by default\nexport default (info: any) => {\n  if (info.unmappedProperty) {\n    throw new Error(\n      `The property \"${info.unmappedProperty}\" in the input was not defined in the context.`\n    );\n  }\n};\n","import jsonld from 'jsonld';\nimport { serializeError } from 'serialize-error';\nimport constants from './constants';\nimport strictExpansionMap from './strictExpansionMap';\nimport getTypeInfo from './getTypeInfo';\n\nimport { IProofSetAddOptions } from './types';\n\nexport class ProofSet {\n  async add(\n    document: any,\n    {\n      suite,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof = true,\n    }: IProofSetAddOptions = { compactProof: true }\n  ) {\n    if (!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if (!documentLoader) {\n      throw new TypeError('\"options.documentLoader\" is required.');\n    }\n    if (!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if (suite.legacy) {\n      throw new TypeError(`Legacy suites are no longer supported.`);\n    }\n\n    if (expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    if (typeof document === 'string') {\n      // fetch document\n      document = await documentLoader(document);\n    }\n\n    // preprocess document to prepare to remove existing proofs\n    let input;\n    if (compactProof) {\n      // cannot assume security context terms, so do full compaction\n      input = await jsonld.compact(document, constants.SECURITY_CONTEXT_URL, {\n        documentLoader,\n        expansionMap,\n        compactToRelative: false,\n      });\n    } else {\n      // TODO: optimize to modify document in place to maximize optimization\n\n      // shallow copy document to allow removal of existing proofs\n      input = { ...document };\n    }\n\n    // save but exclude any existing proof(s)\n    const proofProperty = suite.legacy ? 'signature' : 'proof';\n    //const existingProofs = input[proofProperty];\n    delete input[proofProperty];\n\n    // create the new proof (suites MUST output a proof using the security-v2\n    // `@context`)\n    const proof = await suite.createProof({\n      document: input,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof,\n    });\n\n    if (compactProof) {\n      // compact proof to match document's context\n      let expandedProof;\n      if (suite.legacy) {\n        expandedProof = {\n          [constants.SECURITY_SIGNATURE_URL]: proof,\n        };\n      } else {\n        expandedProof = {\n          [constants.SECURITY_PROOF_URL]: { '@graph': proof },\n        };\n      }\n      // account for type-scoped `proof` definition by getting document types\n      const { types, alias } = await getTypeInfo({\n        document,\n        documentLoader,\n        expansionMap,\n      });\n      expandedProof['@type'] = types;\n      const ctx = jsonld.getValues(document, '@context');\n      const compactProof = await jsonld.compact(expandedProof, ctx, {\n        documentLoader,\n        expansionMap,\n        compactToRelative: false,\n      });\n      delete compactProof[alias];\n      delete compactProof['@context'];\n\n      // add proof to document\n      const key = Object.keys(compactProof)[0];\n      jsonld.addValue(document, key, compactProof[key]);\n    } else {\n      // in-place restore any existing proofs\n      /*if(existingProofs) {\n            document[proofProperty] = existingProofs;\n          }*/\n      // add new proof\n      delete proof['@context'];\n      jsonld.addValue(document, proofProperty, proof);\n    }\n\n    return document;\n  }\n\n  private _getProofs = async ({\n    document,\n    legacy,\n    documentLoader,\n    expansionMap,\n    compactProof,\n  }: any) => {\n    // handle document preprocessing to find proofs\n    const proofProperty = legacy ? 'signature' : 'proof';\n    let proofSet;\n    if (compactProof) {\n      // if we must compact the proof(s) then we must first compact the input\n      // document to find the proof(s)\n      document = await jsonld.compact(\n        document,\n        constants.SECURITY_CONTEXT_URL,\n        { documentLoader, expansionMap, compactToRelative: false }\n      );\n    }\n    proofSet = jsonld.getValues(document, proofProperty);\n    delete document[proofProperty];\n\n    if (proofSet.length === 0) {\n      // no possible matches\n      throw new Error('No matching proofs found in the given document.');\n    }\n\n    // TODO: consider in-place editing to optimize\n\n    // shallow copy proofs and add SECURITY_CONTEXT_URL\n    proofSet = proofSet.map((proof: any) => ({\n      '@context': constants.SECURITY_CONTEXT_URL,\n      ...proof,\n    }));\n\n    return { proofSet, document };\n  };\n\n  private _verify = async ({\n    document,\n    suites,\n    proofSet,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof,\n  }: any) => {\n    // filter out matching proofs\n    const result = await Promise.all(\n      proofSet.map((proof: any) =>\n        purpose.match(proof, { document, documentLoader, expansionMap })\n      )\n    );\n    const matches = proofSet.filter((_value: any, index: any) => result[index]);\n    if (matches.length === 0) {\n      // no matches, nothing to verify\n      return [];\n    }\n\n    // verify each matching proof\n    return (\n      await Promise.all(\n        matches.map(async (proof: any) => {\n          for (const s of suites) {\n            if (\n              await s.matchProof({\n                proof,\n                document,\n                documentLoader,\n                expansionMap,\n              })\n            ) {\n              return s\n                .verifyProof({\n                  proof,\n                  document,\n                  purpose,\n                  documentLoader,\n                  expansionMap,\n                  compactProof,\n                })\n                .catch((error: any) => ({ verified: false, error }));\n            }\n          }\n        })\n      )\n    )\n      .map((r: any, i) => {\n        if (!r) {\n          return null;\n        }\n        if (r.error) {\n          this._addToJSON(r.error);\n        }\n        return { proof: matches[i], ...r };\n      })\n      .filter(r => r);\n  };\n\n  private _addToJSON = (error: any) => {\n    Object.defineProperty(error, 'toJSON', {\n      value: function() {\n        return serializeError(this);\n      },\n      configurable: true,\n      writable: true,\n    });\n  };\n\n  public verify = async (\n    document: any,\n    {\n      suite,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof = true,\n    }: any = {}\n  ) => {\n    if (!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if (!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    const suites = Array.isArray(suite) ? suite : [suite];\n    if (suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n\n    const legacy = suites.some(s => s.legacy);\n    if (legacy) {\n      throw new TypeError(`Legacy suites are no longer supported.`);\n    }\n\n    if (!documentLoader) {\n      throw new TypeError('\"options.documentLoader\" is required.');\n    }\n    if (expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    try {\n      if (typeof document === 'string') {\n        // fetch document\n        document = await documentLoader(document);\n      } else {\n        // TODO: consider in-place editing to optimize when `compactProof`\n        // is `false`\n\n        // shallow copy to allow for removal of proof set prior to canonize\n        document = { ...document };\n      }\n\n      // get proofs from document\n      const { proofSet, document: doc } = await this._getProofs({\n        document,\n        legacy,\n        documentLoader,\n        expansionMap,\n        compactProof,\n      });\n      document = doc;\n\n      // verify proofs\n      const results = await this._verify({\n        document,\n        suites,\n        proofSet,\n        purpose,\n        documentLoader,\n        expansionMap,\n        compactProof,\n      });\n      if (results.length === 0) {\n        throw new Error(\n          'Could not verify any proofs; no proofs matched the required ' +\n            'suite and purpose.'\n        );\n      }\n\n      // combine results\n      const verified = results.some(r => r.verified);\n      if (!verified) {\n        const errors = [].concat(\n          ...results.filter(r => r.error).map(r => r.error)\n        );\n        const result: any = { verified, results };\n        if (errors.length > 0) {\n          result.error = errors;\n        }\n        return result;\n      }\n      return { verified, results };\n    } catch (error) {\n      this._addToJSON(error);\n      return { verified: false, error };\n    }\n  };\n}\n","import jsonld from 'jsonld';\n\nimport { IGetTypeInfoOptions } from './types';\n\nconst getTypeInfo = async ({\n  document,\n  documentLoader,\n  expansionMap,\n}: IGetTypeInfoOptions) => {\n  // determine `@type` alias, if any\n  const ctx = jsonld.getValues(document, '@context');\n  const compacted = await jsonld.compact({ '@type': '_:b0' }, ctx, {\n    documentLoader,\n    expansionMap,\n  });\n  delete compacted['@context'];\n  const alias = Object.keys(compacted)[0];\n\n  // optimize: expand only `@type` and `type` values\n  const toExpand: any = { '@context': ctx };\n  toExpand['@type'] = jsonld\n    .getValues(document, '@type')\n    .concat(jsonld.getValues(document, alias));\n  const expanded =\n    (await jsonld.expand(toExpand, { documentLoader, expansionMap }))[0] || {};\n  return { types: jsonld.getValues(expanded, '@type'), alias };\n};\n\nexport default getTypeInfo;\n","import { ProofSet } from './ProofSet';\n\nimport { ISignOptions } from './types';\n\nexport const sign = async (\n  document: any,\n  {\n    suite,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof,\n  }: ISignOptions = {}\n) => {\n  try {\n    return await new ProofSet().add(document, {\n      suite,\n      purpose,\n      documentLoader,\n      expansionMap,\n      compactProof,\n    });\n  } catch (e) {\n    if (!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {\n        details: { url },\n      } = e;\n      const err: any = new Error(\n        `A URL \"${url}\" could not be fetched;` +\n          `you need to pass \"documentLoader\" or resolve the URL before calling \"sign\".`\n      );\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n","export class VerificationError extends Error {\n  public errors: any[];\n  constructor(errors: any) {\n    super('Verification error(s).');\n\n    this.name = 'VerificationError';\n    this.errors = [].concat(errors);\n  }\n}\n","import { ProofSet } from './ProofSet';\nimport { VerificationError } from './VerificationError';\nimport { IVerifyOptions } from './types';\nexport const verify = async (\n  document: any,\n  {\n    suite,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof,\n  }: IVerifyOptions = {}\n) => {\n  const result = await new ProofSet().verify(document, {\n    suite,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof,\n  });\n  const { error } = result;\n  if (error) {\n    if (!documentLoader && error.name === 'jsonld.InvalidUrl') {\n      const {\n        details: { url },\n      } = error;\n      const urlError = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n          '\"documentLoader\" or resolve the URL before calling \"verify\".'\n      );\n      result.error = new VerificationError(urlError);\n    } else {\n      result.error = new VerificationError(error);\n    }\n  }\n  return result;\n};\n","import { IPurposeValidateOptions } from '../../types';\n\nexport class ProofPurpose {\n  public term: any;\n  public date: any;\n  public maxTimestampDelta: any;\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({ term, date, maxTimestampDelta = Infinity }: any = {}) {\n    if (term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n    if (\n      maxTimestampDelta !== undefined &&\n      typeof maxTimestampDelta !== 'number'\n    ) {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n    this.term = term;\n    if (date !== undefined) {\n      this.date = new Date(date);\n      if (isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n  async validate(proof: any, _options: IPurposeValidateOptions) {\n    try {\n      // check expiration\n      if (this.maxTimestampDelta !== Infinity) {\n        const expected = (this.date || new Date()).getTime();\n        const delta = this.maxTimestampDelta * 1000;\n        const created = new Date(proof.created).getTime();\n        // comparing this way handles NaN case where `created` is invalid\n        if (!(created >= expected - delta && created <= expected + delta)) {\n          throw new Error(\"The proof's created timestamp is out of range.\");\n        }\n      }\n      return { valid: true };\n    } catch (error) {\n      return { valid: false, error };\n    }\n  }\n\n  /**\n   * Called to update a proof when it is being created, adding any properties\n   * specific to this purpose. This method is called prior to the proof\n   * value being generated such that any properties added may be, for example,\n   * included in a digital signature value.\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n   *   to update.\n   *\n   * @return {Promise<object>} resolves to the proof instance (in the\n   *   `constants.SECURITY_CONTEXT_URL`.\n   */\n  async update(proof: any, _options: IPurposeValidateOptions) {\n    proof.proofPurpose = this.term;\n    return proof;\n  }\n\n  /**\n   * Determines if the given proof has a purpose that matches this instance,\n   * i.e. this ProofPurpose instance should be used to validate the given\n   * proof.\n   *\n   * @param proof {object} the proof to check.\n   *\n   * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n   */\n  async match(\n    proof: any\n    // { document, documentLoader, expansionMap }\n  ) {\n    return proof.proofPurpose === this.term;\n  }\n}\n","const { constants: securityConstants } = require('security-context');\nconst { constants: credentialsConstants } = require('credentials-context');\nexport default {\n  CREDENTIALS_CONTEXT_V1_URL: credentialsConstants.CREDENTIALS_CONTEXT_V1_URL,\n  SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,\n  SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,\n  SECURITY_PROOF_URL: 'https://w3id.org/security#proof',\n  SECURITY_SIGNATURE_URL: 'https://w3id.org/security#signature',\n};\n","import { ProofPurpose } from './ProofPurpose';\nimport constants from '../constants';\n\nimport { IPurposeValidateOptions } from '../../types';\n\nconst jsonld = require('jsonld');\n\nexport class ControllerProofPurpose extends ProofPurpose {\n  public controller: any;\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({\n    term,\n    controller,\n    date,\n    maxTimestampDelta = Infinity,\n  }: any = {}) {\n    super({ term, date, maxTimestampDelta });\n    if (controller !== undefined) {\n      if (typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n      this.controller = controller;\n    }\n  }\n\n  async validate(proof: any, _options: IPurposeValidateOptions) {\n    try {\n      const result: any = await super.validate(proof, _options);\n      if (!result.valid) {\n        throw result.error;\n      }\n\n      const { verificationMethod, documentLoader } = _options;\n\n      const { id: verificationId } = verificationMethod;\n\n      // if no `controller` specified, use verification method's\n      if (this.controller) {\n        result.controller = this.controller;\n      } else {\n        // support legacy `owner` property\n        const { controller, owner } = verificationMethod;\n        let controllerId;\n        if (controller) {\n          if (typeof controller === 'object') {\n            controllerId = controller.id;\n          } else if (typeof controller !== 'string') {\n            throw new TypeError(\n              '\"controller\" must be a string representing a URL.'\n            );\n          } else {\n            controllerId = controller;\n          }\n        } else if (owner) {\n          if (typeof owner === 'object') {\n            controllerId = owner.id;\n          } else if (typeof owner !== 'string') {\n            throw new TypeError('\"owner\" must be a string representing a URL.');\n          } else {\n            controllerId = owner;\n          }\n        }\n        // Note: `expansionMap` is intentionally not passed; we can safely drop\n        // properties here and must allow for it\n        const {\n          '@graph': [framed = {}],\n        } = await jsonld.frame(\n          controllerId,\n          {\n            '@context': constants.SECURITY_CONTEXT_URL,\n            id: controllerId,\n            // the term should be in the json-ld object the controllerId resolves\n            // to.\n            [this.term]: {\n              '@embed': '@never',\n              id: verificationId,\n            },\n          },\n          { documentLoader, compactToRelative: false }\n        );\n        result.controller = framed;\n      }\n      const verificationMethods = jsonld.getValues(\n        result.controller,\n        this.term\n      );\n      result.valid = verificationMethods.some(\n        (vm: any) =>\n          vm === verificationId ||\n          (typeof vm === 'object' && vm.id === verificationId)\n      );\n      if (!result.valid) {\n        throw new Error(\n          `Verification method \"${verificationMethod.id}\" not authorized ` +\n            `by controller for proof purpose \"${this.term}\".`\n        );\n      }\n      return result;\n    } catch (error) {\n      return { valid: false, error };\n    }\n  }\n}\n","import { ControllerProofPurpose } from './ControllerProofPurpose';\n\nexport class AssertionProofPurpose extends ControllerProofPurpose {\n  constructor({\n    term = 'assertionMethod',\n    controller,\n    date,\n    maxTimestampDelta = Infinity,\n  }: any = {}) {\n    super({ term, controller, date, maxTimestampDelta });\n  }\n}\n","import { AssertionProofPurpose } from './AssertionProofPurpose';\nconst jsonld = require('jsonld');\n\n/**\n * Creates a proof purpose that will validate whether or not the verification\n * method in a proof was authorized by its declared controller for the\n * proof's purpose.\n */\nexport class CredentialIssuancePurpose extends AssertionProofPurpose {\n  /**\n   * @param {object} options - The options to use.\n   * @param {object} [options.controller] - The description of the controller,\n   *   if it is not to be dereferenced via a `documentLoader`.\n   * @param {string|Date|number} [options.date] - The expected date for\n   *   the creation of the proof.\n   * @param {number} [options.maxTimestampDelta=Infinity] - A maximum number\n   *   of seconds that the date on the signature can deviate from.\n   */\n  constructor({ controller, date, maxTimestampDelta }: any = {}) {\n    super({ controller, date, maxTimestampDelta });\n  }\n\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param {object} proof - The proof to validate.\n   * @param {object} options - The options to use.\n   * @param {object} options.document - The document whose signature is\n   *   being verified.\n   * @param {object} options.suite - Signature suite used in\n   *   the proof.\n   * @param {string} options.verificationMethod - Key id URL to the paired\n   *   public key.\n   * @param {object} [options.documentLoader] - A document loader.\n   * @param {object} [options.expansionMap] - An expansion map.\n   *\n   * @throws {Error} If verification method not authorized by controller.\n   * @throws {Error} If proof's created timestamp is out of range.\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>} Resolves on completion.\n   */\n  async validate(\n    proof: any,\n    { document, suite, verificationMethod, documentLoader, expansionMap }: any\n  ) {\n    try {\n      const result = await super.validate(proof, {\n        document,\n        suite,\n        verificationMethod,\n        documentLoader,\n        expansionMap,\n      });\n\n      if (!result.valid) {\n        throw result.error;\n      }\n\n      const issuer = jsonld.getValues(\n        document,\n        'https://www.w3.org/2018/credentials#issuer'\n      );\n\n      if (!issuer || issuer.length === 0) {\n        throw new Error('Credential issuer is required.');\n      }\n\n      if (result.controller.id !== issuer[0].id) {\n        throw new Error(\n          'Credential issuer must match the verification method controller.'\n        );\n      }\n\n      return { valid: true };\n    } catch (error) {\n      return { valid: false, error };\n    }\n  }\n}\n\nexport default CredentialIssuancePurpose;\n","import { ControllerProofPurpose } from './ControllerProofPurpose';\nimport { IPurposeValidateOptions } from '../../types';\n\nexport class AuthenticationProofPurpose extends ControllerProofPurpose {\n  public challenge: string;\n  public domain: string;\n  constructor({\n    term = 'authentication',\n    controller,\n    challenge,\n    date,\n    domain,\n    maxTimestampDelta = Infinity,\n  }: any = {}) {\n    super({ term, controller, date, maxTimestampDelta });\n    if (typeof challenge !== 'string') {\n      throw new TypeError('\"challenge\" must be a string.');\n    }\n    if (domain !== undefined && typeof domain !== 'string') {\n      throw new TypeError('\"domain\" must be a string.');\n    }\n    this.challenge = challenge;\n    this.domain = domain;\n  }\n\n  async validate(\n    proof: any,\n    {\n      verificationMethod,\n      documentLoader,\n      expansionMap,\n    }: IPurposeValidateOptions\n  ) {\n    try {\n      // check challenge\n      if (proof.challenge !== this.challenge) {\n        throw new Error(\n          'The challenge is not as expected; ' +\n            `challenge=\"${proof.challenge}\", expected=\"${this.challenge}\"`\n        );\n      }\n\n      // check domain\n      if (this.domain !== undefined && proof.domain !== this.domain) {\n        throw new Error(\n          'The domain is not as expected; ' +\n            `domain=\"${proof.domain}\", expected=\"${this.domain}\"`\n        );\n      }\n\n      return super.validate(proof, {\n        verificationMethod,\n        documentLoader,\n        expansionMap,\n      });\n    } catch (error) {\n      return { valid: false, error };\n    }\n  }\n\n  async update(proof: any, _options: IPurposeValidateOptions) {\n    proof = await super.update(proof, _options);\n    proof.challenge = this.challenge;\n    if (this.domain !== undefined) {\n      proof.domain = this.domain;\n    }\n    return proof;\n  }\n}\n","import jsonld from 'jsonld';\nimport constants from './constants';\n\nconst dateRegex = new RegExp(\n  '^(\\\\d{4})-(0[1-9]|1[0-2])-' +\n    '(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):' +\n    '([0-5][0-9]):([0-5][0-9]|60)' +\n    '(\\\\.[0-9]+)?(Z|(\\\\+|-)([01][0-9]|2[0-3]):' +\n    '([0-5][0-9]))$',\n  'i'\n);\n\nfunction _getId(obj: any) {\n  if (typeof obj === 'string') {\n    return obj;\n  }\n\n  if (!('id' in obj)) {\n    return;\n  }\n\n  return obj.id;\n}\n\nexport const checkCredential = (credential: any) => {\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if (typeof credential === 'string') {\n    // might be a JWT... in which case... there is no way to validate....\n    return;\n  }\n  if (credential['@context'][0] !== constants.CREDENTIALS_CONTEXT_V1_URL) {\n    throw new Error(\n      `\"${constants.CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` +\n        'list of contexts.'\n    );\n  }\n\n  // check type presence and cardinality\n  if (!credential['type']) {\n    throw new Error('\"type\" property is required.');\n  }\n\n  if (!jsonld.getValues(credential, 'type').includes('VerifiableCredential')) {\n    throw new Error('\"type\" must include `VerifiableCredential`.');\n  }\n\n  if (!credential['credentialSubject']) {\n    throw new Error('\"credentialSubject\" property is required.');\n  }\n\n  if (!credential['issuer']) {\n    throw new Error('\"issuer\" property is required.');\n  }\n\n  // check issuanceDate cardinality\n  if (jsonld.getValues(credential, 'issuanceDate').length > 1) {\n    throw new Error('\"issuanceDate\" property can only have one value.');\n  }\n\n  // check issued is a date\n  if (!credential['issuanceDate']) {\n    throw new Error('\"issuanceDate\" property is required.');\n  }\n\n  if ('issuanceDate' in credential) {\n    if (!dateRegex.test(credential.issuanceDate)) {\n      throw new Error(\n        `\"issuanceDate\" must be a valid date: ${credential.issuanceDate}`\n      );\n    }\n  }\n\n  // check issuer cardinality\n  if (jsonld.getValues(credential, 'issuer').length > 1) {\n    throw new Error('\"issuer\" property can only have one value.');\n  }\n\n  // check issuer is a URL\n  // FIXME\n  if ('issuer' in credential) {\n    const issuer = _getId(credential.issuer);\n    if (!issuer) {\n      throw new Error(`\"issuer\" id is required.`);\n    }\n    if (!issuer.includes(':')) {\n      throw new Error(`\"issuer\" id must be a URL: ${issuer}`);\n    }\n  }\n\n  if ('credentialStatus' in credential) {\n    if (!credential.credentialStatus.id) {\n      throw new Error('\"credentialStatus\" must include an id.');\n    }\n    if (!credential.credentialStatus.type) {\n      throw new Error('\"credentialStatus\" must include a type.');\n    }\n  }\n\n  // check evidences are URLs\n  // FIXME\n  jsonld.getValues(credential, 'evidence').forEach((evidence: any) => {\n    const evidenceId = _getId(evidence);\n    if (evidenceId && !evidenceId.includes(':')) {\n      throw new Error(`\"evidence\" id must be a URL: ${evidence}`);\n    }\n  });\n\n  // check expires is a date\n  if (\n    'expirationDate' in credential &&\n    !dateRegex.test(credential.expirationDate)\n  ) {\n    throw new Error(\n      `\"expirationDate\" must be a valid date: ${credential.expirationDate}`\n    );\n  }\n};\n","import { EdDSA }  from '@transmute/did-key-ed25519'\n\nimport * as vcjs from '@transmute/vc.js'\n// import {documentLoader} from './documentLoader'\nconst didDoc = require('./did-doc.json')\nconst _credential = require('./credential.json')\n\nconst signerFactory = (controller, jwk) => {\nreturn {\n    sign: (payload, header) => {\n    // typ: 'JWT', MUST NOT be present per well known did configuration...\n    header.kid = controller + jwk.kid;\n    return EdDSA.sign(payload, jwk, header);\n    },\n};\n};\n\nconst verifyFactory = (jwk) => {\nreturn {\n    verify: (jws) => {\n    const verified = EdDSA.verify(jws, jwk, {\n        complete: true,\n    });\n    delete verified.key;\n    return verified;\n    },\n};\n};\n\n\n\n  const signer = signerFactory(\n    'did:example:123',\n    didDoc.publicKey[1].privateKeyJwk\n  );\n  const verifier = verifyFactory(\n    didDoc.publicKey[1].publicKeyJwk\n  );\n\n  const credential = {\n    ..._credential,\n    issuer: { id: didDoc.id },\n    credentialSubject: {\n      ..._credential.credentialSubject,\n      id: didDoc.id,\n    },\n  };\n  const vpOptions = {\n    domain: 'verifier.com',\n    challenge: '7cec01f7-82ee-4474-a4e6-feaaa7351e48',\n  };\n  \n\nexport const testJwt = async ()=>{\n    console.log({didDoc})\n    const credentialIssued = vcjs.jwt.issue(credential, signer);\n    console.log({credentialIssued})\n    const credentialVerified = await vcjs.jwt.verify(\n      credentialIssued,\n      verifier\n    );\n    console.log({credentialVerified})\n    const presentationCreated = vcjs.jwt.createPresentation(\n      [credentialIssued],\n      'did:example:456'\n    );\n    console.log({presentationCreated})\n    const presentationProved = await vcjs.jwt.provePresentation(\n      presentationCreated,\n      vpOptions,\n      signer\n    );\n    console.log({presentationProved})\n    const presentationVerified = await vcjs.jwt.verify(\n      presentationProved,\n      verifier\n    );\n    console.log({presentationVerified})\n}","import jsonld from 'jsonld';\nimport constants from './constants';\n\nexport const checkPresentation = (presentation: any) => {\n  // normalize to an array to allow the common case of context being a string\n  const context = Array.isArray(presentation['@context'])\n    ? presentation['@context']\n    : [presentation['@context']];\n\n  // ensure first context is 'https://www.w3.org/2018/credentials/v1'\n  if (context[0] !== constants.CREDENTIALS_CONTEXT_V1_URL) {\n    throw new Error(\n      `\"${constants.CREDENTIALS_CONTEXT_V1_URL}\" needs to be first in the ` +\n        'list of contexts.'\n    );\n  }\n\n  const types = jsonld.getValues(presentation, 'type');\n\n  // check type presence\n  if (!types.includes('VerifiablePresentation')) {\n    throw new Error('\"type\" must include \"VerifiablePresentation\".');\n  }\n};\n","import jsonld from 'jsonld';\n\nimport { verify as jSigsVerify } from '@transmute/linked-data-proof';\nimport { IVerifyOptions } from '../types';\n\nimport { checkPresentation } from './checkPresentation';\nimport { checkCredential } from './checkCredential';\nimport {\n  AuthenticationProofPurpose,\n  CredentialIssuancePurpose,\n} from './purposes';\n\nconst _verifyCredential = async (options: IVerifyOptions) => {\n  const { credential, checkStatus } = options;\n\n  // run common credential checks\n  checkCredential(credential);\n\n  // if credential status is provided, a `checkStatus` function must be given\n  if (\n    credential.credentialStatus &&\n    typeof options.checkStatus !== 'function'\n  ) {\n    throw new TypeError(\n      'A \"checkStatus\" function must be given to verify credentials with ' +\n        '\"credentialStatus\".'\n    );\n  }\n\n  const { controller } = options;\n  const purpose =\n    options.purpose ||\n    new CredentialIssuancePurpose({\n      controller,\n    });\n\n  const result = await jSigsVerify(credential, {\n    purpose,\n    ...options,\n  });\n\n  // if verification has already failed, skip status check\n  if (!result.verified) {\n    return result;\n  }\n\n  if (credential.credentialStatus) {\n    result.statusResult = await checkStatus(options);\n    if (!result.statusResult.verified) {\n      result.verified = false;\n    }\n  }\n\n  return result;\n};\n\nexport const verifyCredential = async (options: IVerifyOptions) => {\n  const { credential } = options;\n  try {\n    if (!credential) {\n      throw new TypeError('A \"credential\" property is required for verifying.');\n    }\n    return _verifyCredential(options);\n  } catch (error) {\n    return {\n      verified: false,\n      results: [{ credential, verified: false, error }],\n      error,\n    };\n  }\n};\n\nconst _verifyPresentation = async (options: IVerifyOptions) => {\n  const { presentation, unsignedPresentation } = options;\n\n  checkPresentation(presentation);\n\n  // FIXME: verify presentation first, then each individual credential\n  // only if that proof is verified\n\n  // if verifiableCredentials are present, verify them, individually\n  let credentialResults: any;\n  let verified = true;\n  const credentials = jsonld.getValues(presentation, 'verifiableCredential');\n  if (credentials.length > 0) {\n    // verify every credential in `verifiableCredential`\n    credentialResults = await Promise.all(\n      credentials.map((credential: any) => {\n        return verifyCredential({ credential, ...options });\n      })\n    );\n\n    credentialResults = credentialResults.map((cr: any, i: any) => {\n      cr.credentialId = credentials[i].id;\n      return cr;\n    });\n\n    const allCredentialsVerified = credentialResults.every(\n      (r: any) => r.verified\n    );\n    if (!allCredentialsVerified) {\n      verified = false;\n    }\n  }\n\n  if (unsignedPresentation) {\n    // No need to verify the proof section of this presentation\n    return { verified, results: [presentation], credentialResults };\n  }\n\n  const { controller, domain, challenge } = options;\n  if (!options.presentationPurpose && !challenge) {\n    throw new Error(\n      'A \"challenge\" param is required for AuthenticationProofPurpose.'\n    );\n  }\n\n  const purpose =\n    options.presentationPurpose ||\n    new AuthenticationProofPurpose({ controller, domain, challenge });\n\n  const presentationResult = await jSigsVerify(presentation, {\n    purpose,\n    ...options,\n  });\n\n  return {\n    presentationResult,\n    verified: verified && presentationResult.verified,\n    credentialResults,\n    error: presentationResult.error,\n  };\n};\nexport const verify = async (options: IVerifyOptions) => {\n  if (!options.documentLoader) {\n    throw new TypeError(\n      '\"documentLoader\" parameter is required for verifying.'\n    );\n  }\n  const { presentation } = options;\n  try {\n    if (!presentation) {\n      throw new TypeError(\n        'A \"presentation\" property is required for verifying.'\n      );\n    }\n    return _verifyPresentation(options);\n  } catch (error) {\n    return {\n      verified: false,\n      results: [{ presentation, verified: false, error }],\n      error,\n    };\n  }\n};\n","import { sign } from '@transmute/linked-data-proof';\nimport { checkPresentation } from './checkPresentation';\nimport { checkCredential } from './checkCredential';\nimport constants from './constants';\n\nimport { AuthenticationProofPurpose } from './purposes';\n\nexport const createPresentation = ({\n  verifiableCredential,\n  id,\n  holder,\n}: any = {}) => {\n  const presentation: any = {\n    '@context': [constants.CREDENTIALS_CONTEXT_V1_URL],\n    type: ['VerifiablePresentation'],\n  };\n  if (verifiableCredential) {\n    const credentials = [].concat(verifiableCredential);\n    // ensure all credentials are valid\n    for (const credential of credentials) {\n      checkCredential(credential);\n    }\n    presentation.verifiableCredential = credentials;\n  }\n  if (id) {\n    presentation.id = id;\n  }\n  if (holder) {\n    presentation.holder = holder;\n  }\n\n  checkPresentation(presentation);\n\n  return presentation;\n};\n\nexport const signPresentation = async (options: any = {}) => {\n  const { presentation, domain, challenge, documentLoader } = options;\n  const purpose =\n    options.purpose ||\n    new AuthenticationProofPurpose({\n      domain,\n      challenge,\n    });\n\n  if (!documentLoader) {\n    throw new TypeError('\"documentLoader\" parameter is required for issuing.');\n  }\n\n  return sign(presentation, { purpose, ...options });\n};\n","import { sign } from '@transmute/linked-data-proof';\nimport { IIssueOptions } from '../types';\nimport { CredentialIssuancePurpose } from './purposes';\nimport { checkCredential } from './checkCredential';\nexport const issue = (options: IIssueOptions) => {\n  const { credential, suite, documentLoader } = options;\n\n  // run common credential checks\n  if (!credential) {\n    throw new TypeError('\"credential\" parameter is required for issuing.');\n  }\n  checkCredential(credential);\n\n  if (!documentLoader) {\n    throw new TypeError('\"documentLoader\" parameter is required for issuing.');\n  }\n\n  if (!suite) {\n    throw new TypeError('\"suite\" parameter is required for issuing.');\n  }\n  // check to make sure the `suite` has required params\n  // Note: verificationMethod defaults to publicKey.id, in suite constructor...\n  // ...in some implementations...\n  if (!suite.verificationMethod) {\n    throw new TypeError('\"suite.verificationMethod\" property is required.');\n  }\n\n  const purpose = options.purpose || new CredentialIssuancePurpose();\n\n  return sign(credential, { purpose, ...options });\n};\n","import moment from 'moment';\nimport { IVcJwtPayload } from '../types';\n\nimport { checkCredential } from '../vc-ld/checkCredential';\n\nconst isObject = (data: any) => {\n  if (Array.isArray(data)) {\n    return false;\n  }\n  if (\n    (typeof data === 'object' || typeof data === 'function') &&\n    data !== null\n  ) {\n    return true;\n  }\n  return false;\n};\nexport const issue = (credentialTemplate: any, signer: any) => {\n  if (credentialTemplate.issuer === undefined) {\n    throw new Error('Verifiable Credentials require an \"issuer\".');\n  }\n\n  if (\n    credentialTemplate.credentialSubject === undefined ||\n    credentialTemplate.credentialSubject.id === undefined\n  ) {\n    throw new Error('Verifiable Credentials require an \"subject\".');\n  }\n\n  let issuer = isObject(credentialTemplate.issuer)\n    ? credentialTemplate.issuer.id\n    : credentialTemplate.issuer;\n\n  let subject = credentialTemplate.credentialSubject.id;\n\n  checkCredential(credentialTemplate);\n\n  const payload: IVcJwtPayload = {\n    iss: issuer,\n    sub: subject,\n    vc: credentialTemplate,\n  };\n\n  if (credentialTemplate.id) {\n    payload.jti = credentialTemplate.id;\n  }\n\n  if (credentialTemplate.issuanceDate) {\n    payload.nbf = moment(credentialTemplate.issuanceDate).unix();\n  }\n\n  if (credentialTemplate.expirationDate) {\n    payload.exp = moment(credentialTemplate.expirationDate).unix();\n  }\n  // console.log(JSON.stringify(payload, null, 2))\n  const header = {};\n  return signer.sign(payload, header);\n};\n","import { IVcJwtPressentationPayload, IVpOptions } from '../types';\n\nimport { createPresentation as createVerifiablePresentation } from '../vc-ld/prove';\n\nexport const createPresentation = (\n  credentials: any[],\n  holder: string,\n  id?: string\n) => {\n  const vp = createVerifiablePresentation({\n    verifiableCredential: credentials, //array of <object|string> | object | string.... thanks for that...\n    holder,\n    id,\n  });\n\n  const payload: IVcJwtPressentationPayload = {\n    iss: holder,\n    sub: holder,\n    vp: vp,\n  };\n\n  if (vp.id) {\n    payload.jti = vp.id;\n  }\n  return payload;\n};\n\nexport const provePresentation = (\n  vp: any,\n  options: IVpOptions,\n  signer: any\n) => {\n  if (options.challenge) {\n    vp.nonce = options.challenge;\n  }\n  if (options.domain) {\n    vp.aud = options.domain;\n  }\n  const header = {};\n  return signer.sign(vp, header);\n};\n","export const verify = (jws: string, verifier: any) => {\n  return verifier.verify(jws);\n};\n","\nconst unlockedDID = require('./did-doc');\n\nconst localOverrides = {\n  [unlockedDID.id]: unlockedDID,\n  'https://w3id.org/did/v0.11': require('./contexts/did-v0.11.json'),\n  'https://w3id.org/security/v1': require('./contexts/security-v1.json'),\n  'https://w3id.org/security/v2': require('./contexts/security-v2.json'),\n  'https://www.w3.org/2018/credentials/v1': require('./contexts/credentials-v1.json'),\n  'https://www.w3.org/2018/credentials/examples/v1': require('./contexts/examples-v1.json'),\n  'https://www.w3.org/ns/odrl.jsonld': require('./contexts/odrl.json'),\n};\n\nexport const documentLoader =  (url) => {\n\n  const withoutFragment = url.split('#')[0];\n\n  if (localOverrides[withoutFragment]) {\n    return {\n      contextUrl: null, // this is for a context via a link header\n      document: localOverrides[withoutFragment], // this is the actual document that was loaded\n      documentUrl: url, // this is the actual context URL after redirects\n    };\n  }\n\n//   console.warn(url);\n  throw new Error(`No custom context support for ${url}`);\n};\n","import {Ed25519KeyPair}  from '@transmute/did-key-ed25519'\nimport {Ed25519Signature2018}  from '@transmute/ed25519-signature-2018'\nimport * as vcjs from '@transmute/vc.js'\nimport {documentLoader} from './documentLoader'\nconst didDoc = require('./did-doc.json')\nconst _credential = require('./credential.json')\n\nexport const testLd = async ()=>{\n    console.log({didDoc})\n    const key = await Ed25519KeyPair.from(didDoc.publicKey[0])\n    key.id = key.controller + key.id\n    console.log({key})\n    const suite = new Ed25519Signature2018({\n        key,\n        date: '2019-12-11T03:50:55Z',\n    })\n    console.log({suite})\n    const credential = {\n        ..._credential,\n        issuer: { id: didDoc.id },\n        credentialSubject: {\n          ..._credential.credentialSubject,\n          id: didDoc.id,\n        },\n      };\n    const verifiableCredential = await vcjs.ld.issue({\n        credential,\n        suite,\n        documentLoader\n    })\n    console.log({verifiableCredential})\n\n    const id = 'ebc6f1c2';\n    const holder = 'did:ex:12345';\n    const challenge = '123'\n    const presentation = vcjs.ld.createPresentation({\n      verifiableCredential: verifiableCredential,\n      id,\n      holder,\n    });\n    console.log({presentation})\n    const verifiablePresentation = await vcjs.ld.signPresentation({\n      presentation,\n      suite,\n      challenge,\n      documentLoader,\n    });\n    console.log({verifiablePresentation})\n    const presentationVerified = await vcjs.ld.verify({\n      presentation: verifiablePresentation,\n      suite,\n      challenge,\n      documentLoader,\n    });\n    console.log({presentationVerified})\n}","import React from 'react';\nimport { testLd } from './test-ld'\nimport { testJwt } from './test-jwt'\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h4>See Developer Console...</h4>\n     <button onClick={testLd}>Test Linked Data Proof</button>\n     <br/>\n     <br/>\n     <button onClick={testJwt}>Test JSON Web Token</button>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}